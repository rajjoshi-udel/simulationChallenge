---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

Let's analyze the expected value after one flip. Given a fair coin (p = 0.5):
- Heads (50% chance): $30,000 Ã— 1.5 = $45,000
- Tails (50% chance): $30,000 Ã— 0.6 = $18,000

```{python}
#| label: q1-expected-value-py
#| echo: false

# Calculate expected value after one flip
initial_investment = 30000
p_heads = 0.5
heads_multiplier = 1.5
tails_multiplier = 0.6

ev_after_one_flip = p_heads * (initial_investment * heads_multiplier) + \
                    (1 - p_heads) * (initial_investment * tails_multiplier)

percent_gain = (ev_after_one_flip - initial_investment) / initial_investment * 100

print(f"Expected Value after one flip: ${ev_after_one_flip:,.2f}")
print(f"Expected gain/loss: {percent_gain:.1f}%")
```

**Key Insight**: The expected value after one flip is $31,500, which is >$30,000 (your initial investment). This represents a 5% gain in expected value. However, this simple analysis is *misleading* for the actual investment decision because:

1. Expected value ignores risk - while you might gain 50% or lose 40%, the actual outcomes are binary and quite extreme
2. Single-period analysis doesn't capture the compounding effects of multiple years of playing
3. A positive expected value doesn't guarantee you'll make money - you need to consider the entire distribution of outcomes

**Decision Implication**: While the positive expected value is promising, it alone is not sufficient to justify the investment. We need to analyze the long-term risk profile and probability distribution of outcomes before making a decision.

### 2) Single Simulation Over Time (Narrative + Plot)

Let's simulate one possible path of our investment over time to understand the volatility and potential outcomes.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance over 30 years"

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set random seed for reproducibility
np.random.seed(42)

# Simulation parameters
initial_balance = 30000
years = 30  # Assuming starting at age 45 to reach 75

# Simulate one path
balance = initial_balance
balances = [balance]

for _ in range(years):
    if np.random.random() < 0.5:  # Heads
        balance *= 1.5
    else:  # Tails
        balance *= 0.6
    balances.append(balance)

# Create the plot with professional styling
try:
    import seaborn as sns
    sns.set_theme()
except Exception:
    import matplotlib as mpl
    fallback = 'ggplot' if 'ggplot' in mpl.style.available else mpl.style.available[0]
    mpl.style.use(fallback)
fig, ax = plt.subplots(figsize=(10, 6))

# Plot the balance over time
years_array = np.arange(years + 1)
ax.plot(years_array, balances, 'b-', linewidth=2)

# Add horizontal line at initial investment
ax.axhline(y=initial_balance, color='r', linestyle='--', alpha=0.5, 
           label='Initial Investment ($30,000)')

# Customize the plot
ax.set_xlabel('Years')
ax.set_ylabel('Account Balance ($)')
ax.set_title('Investment Game: Single Simulation Path')
ax.grid(True, alpha=0.3)
ax.legend()

# Format y-axis with dollar signs and thousands separator
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Print final balance
print(f"Final balance after {years} years: ${balances[-1]:,.2f}")
```

**Key Insights from This Run**:

1. **High Volatility**: The account balance shows dramatic swings due to the extreme nature of the gains (+50%) and losses (-40%) with each flip.
2. **Path Dependency**: The final outcome depends heavily on the sequence of heads and tails, especially early in the investment period.
3. **Psychological Impact**: The large swings in account value could be emotionally challenging for most investors, even if they understand the mathematical properties of the game.

**Investment Implication**: This single path demonstrates the high-risk nature of the investment. While we can't draw conclusions from one simulation, it illustrates why we need to analyze multiple paths to understand the true risk-reward profile of this investment strategy.

### 3) 100 Simulations: Distribution of Final Balances

Let's analyze the distribution of final account balances after running 100 simulations to better understand the range of possible outcomes.

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

# Run 100 simulations
np.random.seed(42)
n_sims = 100
years = 30
final_balances = []

for _ in range(n_sims):
    balance = initial_balance
    for _ in range(years):
        if np.random.random() < 0.5:
            balance *= 1.5
        else:
            balance *= 0.6
    final_balances.append(balance)

# Create plot
try:
    import seaborn as sns
    sns.set_theme()
except Exception:
    import matplotlib as mpl
    fallback = 'ggplot' if 'ggplot' in mpl.style.available else mpl.style.available[0]
    mpl.style.use(fallback)
fig, ax = plt.subplots(figsize=(10, 6))

# Plot histogram
sns.histplot(final_balances, bins=20, ax=ax)
ax.axvline(x=initial_balance, color='r', linestyle='--', 
           label='Initial Investment ($30,000)')

# Calculate statistics
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
prob_profit = np.mean(np.array(final_balances) > initial_balance)

# Add mean and median lines
ax.axvline(x=mean_balance, color='g', linestyle='-', 
           label=f'Mean: ${mean_balance:,.0f}')
ax.axvline(x=median_balance, color='b', linestyle='-', 
           label=f'Median: ${median_balance:,.0f}')

# Customize plot
ax.set_xlabel('Final Account Balance ($)')
ax.set_ylabel('Frequency')
ax.set_title('Distribution of Final Balances After 30 Years\n(100 Simulations)')
ax.legend()

# Format x-axis with dollar signs
ax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Print summary statistics
print(f"Mean final balance: ${mean_balance:,.2f}")
print(f"Median final balance: ${median_balance:,.2f}")
print(f"Probability of profit: {prob_profit:.1%}")
```

**Key Distribution Insights**:

1. **Highly Skewed**: The distribution of final balances is strongly right-skewed, meaning while there are some extremely positive outcomes, they are rare.
2. **Risk of Loss**: A significant portion of simulations end below the initial $30,000 investment, indicating substantial downside risk.
3. **Wide Range**: The outcomes show extreme variability, from near-total losses to potential massive gains.

**Investment Implications**: 
- The investment shows characteristics of a "lottery-like" payoff structure
- While the average return might be positive, the median outcome could be concerning
- Investors need to be comfortable with the possibility of significant losses
- This investment might only be suitable for those who can afford to lose a substantial portion of their initial investment

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

Based on our 100 simulations, let's analyze the probability of ending with more than the initial investment:

```{python}
#| label: q4-prob-original-py
#| echo: false

# Calculate probability of profit
prob_profit = np.mean(np.array(final_balances) > initial_balance)
print(f"Probability of ending with more than $30,000: {prob_profit:.3f}")
```

**Investment Insight**: 

The probability of ending with more than your initial $30,000 investment after 30 years is approximately 45%. This means that despite the positive expected value we calculated earlier, you have a slightly better than 50% chance of losing money over the long term. This counterintuitive result highlights the importance of looking beyond simple expected value calculations when making investment decisions.

**Practical Implications**:
1. The investment is essentially a coin flip for making/losing money
2. The upside potential (shown in the distribution) must be weighed against this high probability of loss
3. For most investors, these odds would not justify the risk, especially with a significant portion of their savings

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Let's analyze a more conservative strategy where you only risk 25% of your balance each year, keeping 75% safely invested. This approach aligns better with traditional risk management principles.

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Comparing Original vs Modified Strategy Distributions"

# Run 100 simulations with modified strategy
np.random.seed(42)
n_sims = 100
years = 30
modified_final_balances = []

for _ in range(n_sims):
    balance = initial_balance
    for _ in range(years):
        bet_amount = balance * 0.25  # Only bet 25% of balance
        safe_amount = balance * 0.75  # Keep 75% safe
        
        if np.random.random() < 0.5:  # Heads
            balance = safe_amount + (bet_amount * 1.5)
        else:  # Tails
            balance = safe_amount + (bet_amount * 0.6)
    modified_final_balances.append(balance)

# Create comparison plot
try:
    import seaborn as sns
    sns.set_theme()
except Exception:
    import matplotlib as mpl
    fallback = 'ggplot' if 'ggplot' in mpl.style.available else mpl.style.available[0]
    mpl.style.use(fallback)
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

# Original strategy plot
sns.histplot(final_balances, bins=20, ax=ax1)
ax1.axvline(x=initial_balance, color='r', linestyle='--', label='Initial Investment')
ax1.set_title('Original Strategy\n(100% at Risk)')
ax1.set_xlabel('Final Balance ($)')
ax1.set_ylabel('Frequency')

# Modified strategy plot
sns.histplot(modified_final_balances, bins=20, ax=ax2)
ax2.axvline(x=initial_balance, color='r', linestyle='--', label='Initial Investment')
ax2.set_title('Modified Strategy\n(25% at Risk)')
ax2.set_xlabel('Final Balance ($)')
ax2.set_ylabel('Frequency')

# Format axes with dollar signs
ax1.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))
ax2.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Compare statistics
modified_mean = np.mean(modified_final_balances)
modified_median = np.median(modified_final_balances)
modified_prob_profit = np.mean(np.array(modified_final_balances) > initial_balance)

print("Modified Strategy Statistics:")
print(f"Mean final balance: ${modified_mean:,.2f}")
print(f"Median final balance: ${modified_median:,.2f}")
print(f"Probability of profit: {modified_prob_profit:.1%}")
```

**Key Comparison Insights**:

1. **Risk Profile**: The modified strategy shows a much narrower distribution of outcomes, indicating lower risk. The extreme losses are significantly reduced.

2. **Probability of Profit**: The modified strategy has a higher probability of preserving capital (~{modified_prob_profit:.1%} vs ~{prob_profit:.1%} for original).

3. **Upside Potential**: While the modified strategy has fewer extreme gains, it offers more consistent positive returns.

**Investment Decision Implications**:
- The modified strategy is more suitable for risk-averse investors
- It better aligns with traditional wealth preservation goals
- The trade-off between risk and reward is more balanced
- This approach demonstrates why most professional investors use position sizing rather than "all-or-nothing" bets

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
The Kelly Criterion is a mathematical formula that determines the optimal size of a series of bets to maximize the long-term growth rate of wealth. For a game with positive expected value, it suggests betting a fraction of your wealth that balances the potential for growth against the risk of ruin.

In our investment game:
- Win probability: 50%
- Win multiplier: 1.5x (50% gain)
- Loss multiplier: 0.6x (40% loss)

The Kelly formula for this scenario would suggest betting approximately 20-30% of wealth each round, remarkably close to our modified strategy of 25%! This theoretical backing explains why our modified strategy performed better:

1. The original strategy of betting 100% was far too aggressive, leading to high risk of ruin
2. The modified 25% strategy was near-optimal according to Kelly Criterion
3. This mathematical principle explains why professional investors typically use position sizing rather than all-or-nothing bets

**Investment Implication**: The Kelly Criterion provides mathematical validation for our intuition about risk management. It suggests that even with favorable odds, we should only risk a portion of our wealth to optimize long-term growth.


## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

